controller의 역할은 url을 가져오고 finction을 리턴하는 것 <br/>
컨트롤러는 url을 매핑하고, 리퀘스트를 받고, 쿼리를 넘기거나 바디나 그 이외의 것들을 넘기는 것 <br/>
어떠한 한가지 요소가 한 가지 기능은 꼭 책임져야함 .<br/>
서비스는 로직을 관리하는 역할
function을 놓는 곳은 서비스 : 서비스는 비지니스 로직 처리

무언갈 원하면 요청해야함

Query, Body, Param

클라이언트 쪽에서 컨트롤러를 눌러주고 컨르롤러에서 리턴값 넘기는데 그 넘기기 전 사이에
<br/>
서비스 부르고 서비스 측에서 비지니스 로직 처리하고
<br/>
여기서 컨트롤러는 요청을 받아 (서비스 안에 정의된)함수를 호출하는 역할만
<br/>
클라이언트는 컨트롤러에게 뭐가 되었든 암튼 뭐든 요청
<br/>
서비스는 데이터 베이스와 연동하여 CRUD 처리
<br/>
컨트롤러 서비스 둘 다 베이스 동작은 CRUD
<br/>
컨트롤러 서비스는 클래스로 작성 ()
<br/>
컨트롤러 부분에 생성자, 서비스 부분에 @injectable <br/>
:서비스를 컨트롤러에 주입 가능, 컨트롤러에서 생성자로 서비스 생성<br/>
-> 추후 컨트롤러 개개인의 CRUD 컨트롤러에서 생성자로 만든 서비스 클래스의 함수 안에서 비지니스 로직 처리하는 역할로 호출 당할 예정
<br/>
컨트롤러에서는 @로 추가적인 기능제공, 사용을 편리하게 :
파라미터, 바디 (@Param, @Body)
<br/>
id가 없을때 예외처리
<br/>
DTO : 데이터 전송 객체 (data transfer object) <br/>
-> 사람들이 보낼 수 있는거, 보냈으면 하는거 <br/>
-> 프로그래머로서 코드를 더 간결하게 만들 수 있도록 해줌
<br/>
일반적으로 파이프는 미들웨어같은.-> 유효성 검사용
<br/>
nestjs는 타입을 받아서 넘겨줄 떄 자동으로 타입도 반환해 줌
<br/>
dependency injection
<br/>

<!-- 사랑 그것은 엇갈린 너와 나의 시간들,
닿을 수 없는 너의 그리움
나만 있는 나의 깊은 미련들 \_ 크러쉬, 로꼬
폴김 \_ 비 -->
<br/>
nestJS는 express 위에서 돌아감
그래서 컨트롤러에서 request, response 객체가 필요하면 사용할 수도 있음.
<br/>
jest는 js를 아주 쉽게 테스팅하는 npm 패키지
<br/>
.spec.ts는 테스트 파일을 포함한 파일
<br/>
unit test는 모든 function 을 따로 테스팅하는거
테스트 : 유닛테스트, e2e 테스트
